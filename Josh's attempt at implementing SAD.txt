.data 
arr:.word 1,  2,  6,  7,  15,
         3,  5,  8,  14,  16,
         4, 9, 13, 17, 22,
         10, 12, 18, 21, 23,
          11, 19, 20, 24, 25
fileX: .word 5
fileY: .word 5 
window: .word 5, 8   
bestY: .word 0 #store best Y in memory.    
#arr = $a0
#fileX = $s1
#fileY = $s2
#windowY = $s3
#windowX = $s4


# data for printing
space:   .asciiz " "
newline: .asciiz "\n"
finalmsg: .asciiz "Lowest SAD and coordinates:\n"

.text
.globl main
main: 
	la $s0, arr
	lw $s1, fileX
	lw $s2, fileY
	li $s3, 1
	li $s4, 2
	la $s5, window

	#initialization
	add $t0, $t0, $0 #x = 0
	add $t1, $t1, $0 #y = 0
	addi $t2, $0, 1 #dir = 1
	
	#finding xMax and yMax
	#xMax = $t3
	#yMax = $t4
	subi $t3, $s3, 1
	sub $t3, $s1, $t3
	
	subi $t4, $s4, 1
	sub $t4, $s2, $t4
	
	#get xMax-1 and yMax-1 before loop
	subi $t7, $t3, 1 #get xMax-1
	subi $t8, $t4, 1
	
	
	#i = $t5
	#xMax*yMax = $t6
	add $t5, $0, $0
	mul $t6, $t3, $t4
	
	li $s6, 2147483647
	li $s7, 0 #best X
	
	
	
	
	#for loop
loop:	
	beq $t5, $t6, exit   #exit when i = xMax*yMax
	#if(dir == 1)
	
	
	#calculate area of array
	mul $t9, $t1, $s1    # t9 = y * fileX
	add $t9, $t9, $t0    # + x
	sll $t9, $t9, 2      # *4 (bytes per word)
	add $t9, $s0, $t9    # base + offset
	lw  $t9, 0($t9)      # load arr[y][x] 
	
	bne $t2, 1, dirfalse #go to dirfalse if dir != 1
	dirtrue:
		#Check that we dont hit right boundary
		#find if (x == xMax - 1) && (y != yMax - 1))
		bne $t0, $t7 notequal
		beq $t1, $t8, notequal
		
		addi $t1, $t1, 1
		add $t2, $0, $0
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		
		blt $v0, $s6, update_best
		j loop
		
		
		notequal:
		# else if (y == 0 && x != t7)
		bne $t1, $0, notequalagain
		beq $t0, $t7, notequalagain
		
		addi $t0, $t0, 1
		add $t2, $0, $0
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		blt $v0, $s6, update_best
		j loop
		
		
		notequalagain:
		#else
		addi $t0, $t0, 1
		addi $t1, $t1, -1
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		blt $v0, $s6, update_best
		j loop
		 
		
		
	dirfalse:	
		#if((x == 0) && (y != yMax - 1)
		bne $t0, $zero, checktop
		beq $t1, $t8, checktop
		addi $t1, $t1, 1
		addi $t2, $t2, 1
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		blt $v0, $s6, update_best
		j loop
		
		
		checktop:
		#else if((y == yMax - 1) && (x != xMax - 1))
		bne $t1, $t8, nonehit
		beq $t0, $t7, nonehit
		addi $t0, $t0, 1
		addi $t2, $t2, 1
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		blt $v0, $s6, update_best
		j loop
		
		nonehit:
		#else
		addi $t0, $t0, -1
		addi $t1, $t1, 1
		addi $t5, $t5, 1
		jal print
		
move $a0, $s0    # arr base address
move $a1, $t0    # current x
move $a2, $t1    # current y
move $a3, $s1    # fileX (width)
		jal SAD
		blt $v0, $s6, update_best
		j loop
		
	       update_best:
    	        move $s6, $v0        # lowest SAD
   		move $s7, $t0       # bestX
    		sw $t1, bestY      # bestY
    		
   		j loop
exit:
  li $v0, 4
    la $a0, finalmsg
    syscall

    li $v0, 1
    move $a0, $s6        # lowest SAD
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    lw $a0, bestY
    li $v0, 1     # bestY
    syscall

    li $v0, 4
    la $a0, space
    syscall

    move $a0, $s7     # bestX
    li $v0, 1
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    
	jr $ra
	
	
	
print:	
	# print the array value (in $t9)
    li $v0, 1
    move $a0, $t9
    syscall

    # print a space
    li $v0, 4
    la $a0, space
    syscall

    # print loop counter i ($t5)
    li $v0, 1
    move $a0, $t5
    syscall

    # print newline
    li $v0, 4
    la $a0, newline
    syscall

    jr $ra


SAD:
   addi $sp, $sp, -48
sw $ra,  0($sp)
sw $t0,  4($sp)   # save t0 (used in main as x or loop var)
sw $t1,  8($sp)   # save t1 (used in main as y or loop var)
sw $t2, 12($sp)
sw $t3, 16($sp)
sw $t4, 20($sp)
sw $t5, 24($sp)
sw $t6, 28($sp)
sw $t7, 32($sp)
sw $t8, 36($sp)
sw $t9, 40($sp)

    li $t0, 0          # i = 0
    li $t9, 0

outLoop:
    bge $t0, $s3, endSAD   # if i >= windowY, exit

    li $t1, 0          # j = 0

inLoop:
    bge $t1, $s4, nextRow  # if j >= windowX, go to next row

    # Calculate address for arr[y+i][x+j]

add $t2, $a2, $t0    # t2 = y + i
add $t3, $a1, $t1    # t3 = x + j
mul $t4, $t2, $a3    # t4 = (y + i) * fileX
add $t4, $t4, $t3    # t4 = (y + i) * fileX + (x + j)
sll $t4, $t4, 2      # byte offset in arr (word = 4 bytes)

add $t5, $a0, $t4    # arr base + offset = address of arr[y+i][x+j]
lw  $t6, 0($t5)      # load value from arr[y+i][x+j]

    # Calculate address for window[i][j]
    mul $t7, $t0, $s4   # t7 = i * windowX
    add $t7, $t7, $t1   # t7 = i*windowX + j
    sll $t7, $t7, 2     # byte offset

    add $t8, $s5, $t7   # window base + offset
    lw  $t9, 0($t8)     # load window[i][j]

    # Compute absolute difference
    sub $t2, $t6, $t9   # arr[y+i][x+j] - window[i][j]
    bltz $t2, make_positive
    add $t9, $t9, $t2   # t7 = sum + difference
    j continueSAD

make_positive:
    sub $t2, $zero, $t2
    add $t9, $t9, $t2   # sum + abs difference

continueSAD:
    addi $t1, $t1, 1
    j inLoop

nextRow:
    addi $t0, $t0, 1
    j outLoop

endSAD:
    # save sum somewhere or return it
    move $v0, $t9
lw $ra,  0($sp)
lw $t0,  4($sp)
lw $t1,  8($sp)
lw $t2, 12($sp)
lw $t3, 16($sp)
lw $t4, 20($sp)
lw $t5, 24($sp)
lw $t6, 28($sp)
lw $t7, 32($sp)
lw $t8, 36($sp)
lw $t9, 40($sp)
addi $sp, $sp, 48
jr $ra
	  
	  
    
    
    
    
    
    		
	
